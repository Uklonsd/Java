
Відповідь до 1 контрольного питання:
Різниця між ключовими та зарезервованими словами полягає в тому, що ключові слова мають спеціальне синтаксичне значення в мові програмування і не можуть використовуватися для іменування змінних або функцій,
тоді як зарезервовані слова лише зарезервовані для можливого використання в майбутньому і на даний момент не мають особливого синтаксичного значення.
Відповідь до 2 контрольного питання:
int (цілі числа), double (дробові числа з плаваючою комою), boolean (логічний тип), char (символ), byte (8-бітні цілі числа), 
short (16-бітні цілі числа), long (64-бітні цілі числа), float (32-бітні дробові числа з плаваючою комою.
Відповідь до 3 контрольного питання:
Знакові типи даних можуть представляти від'ємні та позитивні значення, включаючи нуль, і включають в себе типи як int і long у Java. Беззнакові типи даних можуть представляти тільки позитивні значення 
і не мають від'ємного діапазону. Проте, Java не має беззнакових примітивних типів.
Відповідь до 4 контрольного питання:
Максимальні значення для знакових цілих типів даних можуть відрізнятися в залежності від конкретної мови програмування та комп'ютерної архітектури. У Java це можна визначити використовуючи вбудовані константи:
short: Максимальне значення для short у Java дорівнює 32,767.
char: Максимальне значення для char у Java дорівнює 65,535, оскільки він представляє беззнаковий 16-бітний символ Unicode.
int: Максимальне значення для int у Java дорівнює 2,147,483,647.
long: Максимальне значення для long у Java дорівнює 9,223,372,036,854,775,807.
Відповідь до 5 контрольного питання:
                 Діапазон значень для змінної типу byte, який становить від -128 до 127, обумовлений внутрішньою реалізацією даного типу в Java і подібних мовах програмування. Цей діапазон вибраний з міркувань зручності та оптимізації пам'яті.
                        
                        Тип byte використовує 8 біт (1 байт) для представлення значення, і перший біт (найстарший біт) використовується для визначення знаку. Тобто, 7 біт використовуються для представлення модуля числа, і один біт вказує на його знак: 0 для позитивного числа і 1 для від'ємного числа.
                        
                        Цей підхід дозволяє представити діапазон від -128 до 127. Вибір такого діапазону дозволяє зберегти симетричну структуру, де від'ємні та позитивні значення можна представити за допомогою одного і того ж типу даних, що спрощує обробку чисел.\
                        
                        Щодо питання про кількість від'ємних і додатних значень, то це обумовлено тим, що нуль також вважається позитивним числом. Таким чином, з 7 бітами на модуль числа, можна представити 2^7 = 128 різних значень, включаючи 0. З цих 128 значень половина (64) відводиться позитивним числам, а інша половина - від'ємним. 
Відповідь до 6 контрольного питання:
Система числення - це спосіб представлення чисел, який включає в себе символи або цифри та правила для їх комбінування для утворення чисел. Дві найпоширеніші системи числення - це десяткова (заснована на числі 10) та двійкова (заснована на числі 2).Наприклад, для перетворення двійкового числа \"1101\" в десяткову систему числення:
                        
        "1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 8 + 4 + 0 + 1 = 13.
                        
        І для перетворення десяткового числа 13 в двійкову:
                        
               13 / 2 = 6 (залишок 1)
                       6 / 2 = 3 (залишок 0)
                        3 / 2 = 1 (залишок 1)
                        1 / 2 = 0 (залишок 1)
                      
                        Залишки від запам'ятаних ділень від останнього до першого дають двійкове число 1101. 
Відповідь до 7 контрольного питання:
Доповняльний код (complement code) - це спеціальний спосіб представлення від'ємних чисел в системі числення з підйому на потужність. Зазвичай доповняльний код використовується в двійковій системі числення, але такий підхід може бути реалізований в інших системах числення також. 
Відповідь до 8 контрольного питання:
Обидва числа a і b дорівнюють 2,000,000,000. Однак у Java тип int є 32-бітним, і він може представляти значення в діапазоні від -2,147,483,648 до 2,147,483,647. Оскільки сума a + b перевищує максимальне значення для типу int (4,294,967,295), то результат виразу a + b виходить за межі допустимого діапазону цього типу. Це призводить до переповнення, тобто зациклення значення назад до мінімально можливого значення для типу int, яке дорівнює -2,147,483,648. 
Відповідь до 9 контрольного питання:
Таким чином, double зазвичай використовується, коли необхідна вища точність в обчисленнях, а float може бути корисним для економії пам'яті, коли ви знаєте, що менша точність не є критичною. ");
Відповідь до 10 контрольного питання:
Число з рухомою комою (або число з плаваючою комою) - це спосіб представлення дійсних чисел, який включає в себе дві головні складові: мантису і степінь.
                        
                        "Мантиса (fraction): Мантиса - це фрагмент числа, який включає всі значущі цифри числа. Вона представляє собою частину числа, яка знаходиться після десяткової коми. Наприклад, в числі 123.45 мантиса - це \"12345\". Мантиса може бути будь-якого розміру і має важливий вплив на точність представлення числа.
                      
                        "Степінь (exponent): Степінь вказує на позицію десяткової коми в числі. Він визначає масштаб числа, тобто, наскільки великим або малим буде число. Степінь може бути цілим числом, і він піднімаєся до основи 2 (у бінарних системах числення) або 10 (у десятковій системі). 
Відповідь до 11 контрольного питання:
Double.NaN - це спеціальне значення в мові програмування Java, яке позначає \"не число\" (Not-a-Number). Воно використовується, коли результат обчислення або операції не може бути коректно представлений як число з плаваючою комою, і вказує на виникнення помилки або неможливість виконання операції. 
Відповідь до 12 контрольного питання:
Фрагмент коду, який порівнює Double.NaN з Double.NaN, виведе false. Це виглядає дивно на перший погляд, але пояснимо, чому це так.
                  
                        NaN (Not-a-Number) - це спеціальне значення, яке вказує на те, що результат операції або число не є коректним числом з плаваючою комою. Важливо зрозуміти, що NaN не дорівнює нічому, включаючи інше NaN. Вони не можуть бути порівняні за допомогою оператора == (рівності).
                      
                        Щоб порівняти, чи змінна містить NaN, треба використовувати методи Double.isNaN() або Double.compare(). Таким чином, результат Double.NaN == Double.NaN завжди буде false, оскільки NaN не може бути порівняне з іншим NaN за допомогою оператора ==. 
Відповідь до 13 контрольного питання:
Преінкремент і постінкремент - це дві операції в програмуванні, які збільшують значення змінної на одиницю. Різниця між ними полягає у часі, коли змінюється значення змінної і коли воно використовується в операціях. 
Відповідь до 14 контрольного питання:
Різниця між ними полягає в їхньому призначенні і контексті використання. Логічна операція AND призначена для роботи з булевими умовами і має короткозамкнуту версію, оскільки важливо забезпечити оптимізацію та уникнути надмірних обчислень у логічних виразах. Побітова операція AND використовується для роботи з окремими бітами чисел і не має короткозамкненої версії, оскільки всі біти повинні бути оброблені незалежно від інших. 
Відповідь до 15 контрольного питання:
Основна різниця між OR та XOR полягає в тому, як вони обробляють випадки, коли обидві умови A і B є true. OR повертає true у цьому випадку, в той час як XOR повертає false. 
Відповідь до 16 контрольного питання:
                 boolean a = true && false | false
                        
                        "У цьому виразі ми маємо комбінацію логічних операторів AND (&&) і OR (|).
                        "Спочатку обчислюється true && false, що дорівнює false, оскільки обидві умови мають бути true, щоб результат був true.
                        "Потім обчислюється false | false, що дорівнює false, оскільки обидві умови мають бути false, щоб результат був false.
                        "Тому значення змінної a стає false.
                        "boolean b = true && false || false
                        
                        "У цьому виразі також маємо комбінацію логічних операторів AND (&&) і OR (||).
                        "Спочатку обчислюється true && false, що дорівнює false, оскільки обидві умови мають бути true, щоб результат був true.
                        "Потім обчислюється false || false, що дорівнює false, оскільки жодна з умов не є true.
                        "Тому значення змінної b стає false.
                        "Зараз, коли ми визначили значення змінних a і b, вони вже мають значення false. Отже, виклик System.out.println(a = false); виведе false, а виклик System.out.println(b = true); виведе true. 
